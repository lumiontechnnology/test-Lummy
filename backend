// ============================================
// BACKEND STRUCTURE
// ============================================

// ===== package.json =====
{
  "name": "lummy-backend",
  "version": "1.0.0",
  "scripts": {
    "dev": "nodemon --exec ts-node src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.27.0",
    "@prisma/client": "^5.20.0",
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "bcrypt": "^5.1.1",
    "jsonwebtoken": "^9.0.2",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "socket.io": "^4.7.0",
    "redis": "^4.6.0",
    "bull": "^4.12.0",
    "axios": "^1.6.0",
    "dotenv": "^16.4.0",
    "zod": "^3.22.0",
    "express-rate-limit": "^7.1.0",
    "express-validator": "^7.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@types/express": "^4.17.21",
    "@types/bcrypt": "^5.0.2",
    "@types/jsonwebtoken": "^9.0.5",
    "typescript": "^5.3.0",
    "nodemon": "^3.0.0",
    "ts-node": "^10.9.0",
    "prisma": "^5.20.0"
  }
}

// ===== tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

// ===== .env.example =====
NODE_ENV=development
PORT=5000
DATABASE_URL=postgresql://user:password@localhost:5432/lummy
JWT_SECRET=your-super-secret-jwt-key-change-this
JWT_REFRESH_SECRET=your-refresh-secret-key-change-this
REDIS_URL=redis://localhost:6379
ANTHROPIC_API_KEY=your-anthropic-api-key
FRONTEND_URL=http://localhost:3000
CORS_ORIGIN=http://localhost:3000

// ===== prisma/schema.prisma =====
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  companyName   String    @map("company_name")
  industry      String?
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  
  agents        Agent[]
  
  @@map("users")
}

model Agent {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  name            String
  status          AgentStatus @default(LEARNING)
  learningStage   Int       @default(0) @map("learning_stage")
  voiceProfile    Json      @map("voice_profile")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversations   Conversation[]
  learningData    LearningData[]
  voicePatterns   VoicePattern[]
  
  @@map("agents")
}

enum AgentStatus {
  LEARNING
  ACTIVE
  PAUSED
}

model Conversation {
  id              String    @id @default(uuid())
  agentId         String    @map("agent_id")
  customerEmail   String?   @map("customer_email")
  customerName    String?   @map("customer_name")
  channel         Channel   @default(CHAT)
  status          ConversationStatus @default(ACTIVE)
  sentiment       Float?
  metadata        Json?
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  agent           Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  messages        Message[]
  learningData    LearningData[]
  
  @@map("conversations")
}

enum Channel {
  EMAIL
  CHAT
  PHONE
  SLACK
}

enum ConversationStatus {
  ACTIVE
  RESOLVED
  ESCALATED
}

model Message {
  id              String    @id @default(uuid())
  conversationId  String    @map("conversation_id")
  senderType      SenderType @map("sender_type")
  content         String
  metadata        Json?
  createdAt       DateTime  @default(now()) @map("created_at")
  
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@map("messages")
}

enum SenderType {
  CUSTOMER
  AI
  HUMAN
}

model LearningData {
  id                String    @id @default(uuid())
  agentId           String    @map("agent_id")
  conversationId    String?   @map("conversation_id")
  interactionType   String    @map("interaction_type")
  patternDetected   Json      @map("pattern_detected")
  confidenceScore   Float     @map("confidence_score")
  applied           Boolean   @default(false)
  createdAt         DateTime  @default(now()) @map("created_at")
  
  agent             Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  conversation      Conversation? @relation(fields: [conversationId], references: [id])
  
  @@map("learning_data")
}

model VoicePattern {
  id              String    @id @default(uuid())
  agentId         String    @map("agent_id")
  patternType     PatternType @map("pattern_type")
  patternData     Json      @map("pattern_data")
  frequency       Int       @default(0)
  lastUsed        DateTime? @map("last_used")
  createdAt       DateTime  @default(now()) @map("created_at")
  
  agent           Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  
  @@map("voice_patterns")
}

enum PatternType {
  GREETING
  CLOSING
  TONE
  VOCABULARY
  STRUCTURE
}

// ===== src/config/database.ts =====
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

export default prisma;

// ===== src/config/redis.ts =====
import { createClient } from 'redis';

const redisClient = createClient({
  url: process.env.REDIS_URL || 'redis://localhost:6379',
});

redisClient.on('error', (err) => console.error('Redis Client Error', err));
redisClient.on('connect', () => console.log('✓ Redis connected'));

export const connectRedis = async () => {
  if (!redisClient.isOpen) {
    await redisClient.connect();
  }
};

export default redisClient;

// ===== src/config/anthropic.ts =====
import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

export default anthropic;

// ===== src/middleware/auth.ts =====
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import prisma from '../config/database';

export interface AuthRequest extends Request {
  user?: {
    id: string;
    email: string;
  };
}

export const authenticate = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {
      userId: string;
      email: string;
    };

    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { id: true, email: true },
    });

    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

// ===== src/middleware/rateLimiter.ts =====
import rateLimit from 'express-rate-limit';

export const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 100,
  message: 'Too many requests, please try again later',
});

export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5,
  message: 'Too many login attempts, please try again later',
});

// ===== src/services/ai/claude.service.ts =====
import anthropic from '../../config/anthropic';
import { MessageParam } from '@anthropic-ai/sdk/resources';

export class ClaudeService {
  async generateResponse(
    conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }>,
    voiceProfile: any,
    systemPrompt?: string
  ): Promise<string> {
    try {
      const messages: MessageParam[] = conversationHistory.map(msg => ({
        role: msg.role,
        content: msg.content,
      }));

      const defaultSystemPrompt = this.buildSystemPrompt(voiceProfile);

      const response = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1000,
        system: systemPrompt || defaultSystemPrompt,
        messages,
      });

      const content = response.content[0];
      return content.type === 'text' ? content.text : '';
    } catch (error) {
      console.error('Claude API Error:', error);
      throw new Error('Failed to generate AI response');
    }
  }

  private buildSystemPrompt(voiceProfile: any): string {
    const { tone, formality, vocabulary, personality } = voiceProfile;
    
    return `You are a customer service and sales AI agent. Your communication style:
- Tone: ${tone || 'professional and friendly'}
- Formality: ${formality || 'balanced'}
- Key vocabulary: ${vocabulary?.join(', ') || 'standard business terms'}
- Personality traits: ${personality || 'helpful and empathetic'}

Always maintain this voice consistently. Be helpful, accurate, and aim to resolve customer inquiries efficiently.`;
  }

  async analyzeSentiment(text: string): Promise<number> {
    try {
      const response = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 100,
        messages: [{
          role: 'user',
          content: `Analyze the sentiment of this message on a scale from -1 (very negative) to 1 (very positive). Respond only with the number: "${text}"`,
        }],
      });

      const content = response.content[0];
      const sentimentText = content.type === 'text' ? content.text : '0';
      return parseFloat(sentimentText.trim()) || 0;
    } catch (error) {
      console.error('Sentiment analysis error:', error);
      return 0;
    }
  }
}

export default new ClaudeService();

// ===== src/services/learning/pattern.service.ts =====
import prisma from '../../config/database';
import redisClient from '../../config/redis';

export class PatternService {
  async analyzeConversation(agentId: string, conversationId: string) {
    const messages = await prisma.message.findMany({
      where: { conversationId },
      orderBy: { createdAt: 'asc' },
    });

    const patterns = {
      greetings: [] as string[],
      closings: [] as string[],
      commonPhrases: [] as string[],
      tone: 'neutral',
    };

    messages.forEach(message => {
      if (message.senderType === 'HUMAN') {
        // Extract patterns from human responses
        const content = message.content.toLowerCase();
        
        // Detect greetings
        if (this.isGreeting(content)) {
          patterns.greetings.push(message.content);
        }
        
        // Detect closings
        if (this.isClosing(content)) {
          patterns.closings.push(message.content);
        }
      }
    });

    await this.storePatterns(agentId, patterns);
    return patterns;
  }

  private isGreeting(text: string): boolean {
    const greetingWords = ['hello', 'hi', 'hey', 'good morning', 'good afternoon', 'greetings'];
    return greetingWords.some(word => text.includes(word));
  }

  private isClosing(text: string): boolean {
    const closingWords = ['goodbye', 'bye', 'thanks', 'thank you', 'have a great', 'take care'];
    return closingWords.some(word => text.includes(word));
  }

  async storePatterns(agentId: string, patterns: any) {
    // Store in Redis for quick access
    const cacheKey = `agent:${agentId}:patterns`;
    await redisClient.set(cacheKey, JSON.stringify(patterns), { EX: 3600 });

    // Store in database for persistence
    for (const [type, data] of Object.entries(patterns)) {
      if (Array.isArray(data) && data.length > 0) {
        await prisma.voicePattern.create({
          data: {
            agentId,
            patternType: type.toUpperCase() as any,
            patternData: data,
            frequency: data.length,
          },
        });
      }
    }
  }

  async getAgentPatterns(agentId: string) {
    // Try Redis first
    const cacheKey = `agent:${agentId}:patterns`;
    const cached = await redisClient.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }

    // Fallback to database
    const patterns = await prisma.voicePattern.findMany({
      where: { agentId },
      orderBy: { frequency: 'desc' },
    });

    return patterns.reduce((acc, pattern) => {
      acc[pattern.patternType.toLowerCase()] = pattern.patternData;
      return acc;
    }, {} as any);
  }
}

export default new PatternService();

// ===== src/services/learning/voice.service.ts =====
import prisma from '../../config/database';
import claudeService from '../ai/claude.service';

export class VoiceService {
  async buildVoiceProfile(agentId: string) {
    const conversations = await prisma.conversation.findMany({
      where: { agentId },
      include: {
        messages: {
          where: { senderType: 'HUMAN' },
          take: 50, // Analyze last 50 human messages
        },
      },
    });

    const allMessages = conversations.flatMap(c => c.messages);
    
    if (allMessages.length === 0) {
      return this.getDefaultVoiceProfile();
    }

    const profile = {
      tone: await this.analyzeTone(allMessages),
      formality: await this.analyzeFormality(allMessages),
      vocabulary: this.extractVocabulary(allMessages),
      avgResponseLength: this.calculateAvgLength(allMessages),
      personality: await this.detectPersonality(allMessages),
    };

    // Update agent's voice profile
    await prisma.agent.update({
      where: { id: agentId },
      data: { voiceProfile: profile },
    });

    return profile;
  }

  private async analyzeTone(messages: any[]): Promise<string> {
    const sentiments = await Promise.all(
      messages.slice(0, 10).map(m => claudeService.analyzeSentiment(m.content))
    );
    
    const avgSentiment = sentiments.reduce((a, b) => a + b, 0) / sentiments.length;
    
    if (avgSentiment > 0.3) return 'enthusiastic';
    if (avgSentiment > 0) return 'positive';
    if (avgSentiment > -0.3) return 'neutral';
    return 'serious';
  }

  private async analyzeFormality(messages: any[]): Promise<string> {
    const formalWords = ['please', 'kindly', 'regards', 'sincerely', 'appreciate'];
    const casualWords = ['hey', 'yeah', 'cool', 'awesome', 'thanks'];
    
    let formalCount = 0;
    let casualCount = 0;

    messages.forEach(msg => {
      const content = msg.content.toLowerCase();
      formalCount += formalWords.filter(w => content.includes(w)).length;
      casualCount += casualWords.filter(w => content.includes(w)).length;
    });

    if (formalCount > casualCount * 1.5) return 'formal';
    if (casualCount > formalCount * 1.5) return 'casual';
    return 'balanced';
  }

  private extractVocabulary(messages: any[]): string[] {
    const words = messages
      .map(m => m.content.split(/\s+/))
      .flat()
      .map(w => w.toLowerCase().replace(/[^a-z]/g, ''))
      .filter(w => w.length > 3);

    const frequency: Record<string, number> = {};
    words.forEach(word => {
      frequency[word] = (frequency[word] || 0) + 1;
    });

    return Object.entries(frequency)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 20)
      .map(([word]) => word);
  }

  private calculateAvgLength(messages: any[]): number {
    const lengths = messages.map(m => m.content.length);
    return lengths.reduce((a, b) => a + b, 0) / lengths.length;
  }

  private async detectPersonality(messages: any[]): Promise<string> {
    // Simple personality detection based on message characteristics
    const traits = [];
    
    const allText = messages.map(m => m.content).join(' ');
    
    if (allText.includes('!')) traits.push('enthusiastic');
    if (allText.match(/\b(help|assist|support)\b/gi)) traits.push('helpful');
    if (allText.match(/\b(understand|feel|appreciate)\b/gi)) traits.push('empathetic');
    
    return traits.join(', ') || 'professional';
  }

  private getDefaultVoiceProfile() {
    return {
      tone: 'professional',
      formality: 'balanced',
      vocabulary: [],
      avgResponseLength: 150,
      personality: 'helpful and friendly',
    };
  }
}

export default new VoiceService();

// ===== src/controllers/auth.controller.ts =====
import { Request, Response } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import prisma from '../config/database';

export class AuthController {
  async register(req: Request, res: Response) {
    try {
      const { email, password, companyName, industry } = req.body;

      const existingUser = await prisma.user.findUnique({ where: { email } });
      if (existingUser) {
        return res.status(400).json({ error: 'Email already registered' });
      }

      const passwordHash = await bcrypt.hash(password, 10);

      const user = await prisma.user.create({
        data: {
          email,
          passwordHash,
          companyName,
          industry,
        },
      });

      // Create default agent
      await prisma.agent.create({
        data: {
          userId: user.id,
          name: `${companyName} Agent`,
          voiceProfile: {},
        },
      });

      const token = this.generateToken(user.id, user.email);

      res.status(201).json({
        user: {
          id: user.id,
          email: user.email,
          companyName: user.companyName,
        },
        token,
      });
    } catch (error) {
      console.error('Registration error:', error);
      res.status(500).json({ error: 'Registration failed' });
    }
  }

  async login(req: Request, res: Response) {
    try {
      const { email, password } = req.body;

      const user = await prisma.user.findUnique({ where: { email } });
      if (!user) {
        return res.status(401).json({ error: 'Invalid credentials' });
      }

      const validPassword = await bcrypt.compare(password, user.passwordHash);
      if (!validPassword) {
        return res.status(401).json({ error: 'Invalid credentials' });
      }

      const token = this.generateToken(user.id, user.email);

      res.json({
        user: {
          id: user.id,
          email: user.email,
          companyName: user.companyName,
        },
        token,
      });
    } catch (error) {
      console.error('Login error:', error);
      res.status(500).json({ error: 'Login failed' });
    }
  }

  private generateToken(userId: string, email: string): string {
    return jwt.sign(
      { userId, email },
      process.env.JWT_SECRET!,
      { expiresIn: '7d' }
    );
  }
}

export default new AuthController();

// ===== src/controllers/chat.controller.ts =====
import { Socket } from 'socket.io';
import prisma from '../config/database';
import claudeService from '../services/ai/claude.service';
import voiceService from '../services/learning/voice.service';

export class ChatController {
  async handleMessage(socket: Socket, data: any) {
    try {
      const { agentId, message, conversationId } = data;

      let conversation;
      if (conversationId) {
        conversation = await prisma.conversation.findUnique({
          where: { id: conversationId },
          include: { messages: { orderBy: { createdAt: 'asc' } } },
        });
      } else {
        conversation = await prisma.conversation.create({
          data: {
            agentId,
            channel: 'CHAT',
            status: 'ACTIVE',
          },
          include: { messages: true },
        });
      }

      // Save customer message
      await prisma.message.create({
        data: {
          conversationId: conversation.id,
          senderType: 'CUSTOMER',
          content: message,
        },
      });

      // Get agent's voice profile
      const agent = await prisma.agent.findUnique({
        where: { id: agentId },
      });

      // Build conversation history
      const history = conversation.messages.map(m => ({
        role: m.senderType === 'CUSTOMER' ? 'user' as const : 'assistant' as const,
        content: m.content,
      }));

      history.push({ role: 'user', content: message });

      // Generate AI response
      const aiResponse = await claudeService.generateResponse(
        history,
        agent?.voiceProfile || {}
      );

      // Save AI response
      await prisma.message.create({
        data: {
          conversationId: conversation.id,
          senderType: 'AI',
          content: aiResponse,
        },
      });

      // Emit response back to client
      socket.emit('ai-response', {
        conversationId: conversation.id,
        message: aiResponse,
      });

      // Update learning data
      await prisma.learningData.create({
        data: {
          agentId,
          conversationId: conversation.id,
          interactionType: 'customer_query',
          patternDetected: { query: message, response: aiResponse },
          confidenceScore: 0.8,
        },
      });

    } catch (error) {
      console.error('Chat error:', error);
      socket.emit('error', { message: 'Failed to process message' });
    }
  }
}

export default new ChatController();

// ===== src/routes/auth.routes.ts =====
import { Router } from 'express';
import authController from '../controllers/auth.controller';
import { authLimiter } from '../middleware/rateLimiter';

const router = Router();

router.post('/register', authLimiter, authController.register.bind(authController));
router.post('/login', authLimiter, authController.login.bind(authController));

export default router;

// ===== src/routes/agent.routes.ts =====
import { Router } from 'express';
import { authenticate, AuthRequest } from '../middleware/auth';
import prisma from '../config/database';
import voiceService from '../services/learning/voice.service';

const router = Router();

router.get('/', authenticate, async (req: AuthRequest, res) => {
  try {
    const agents = await prisma.agent.findMany({
      where: { userId: req.user!.id },
    });
    res.json(agents);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch agents' });
  }
});

router.get('/:id', authenticate, async (req: AuthRequest, res) => {
  try {
    const agent = await prisma.agent.findFirst({
      where: {
        id: req.params.id,
        userId: req.user!.id,
      },
    });
    
    if (!agent) {
      return res.status(404).json({ error: 'Agent not found' });
    }
    
    res.json(agent);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch agent' });
  }
});

router.post('/:id/rebuild-voice', authenticate, async (req: AuthRequest, res) => {
  try {
    const profile = await voiceService.buildVoiceProfile(req.params.id);
    res.json({ message: 'Voice profile rebuilt', profile });
  } catch (error) {
    res.status(500).json({ error: 'Failed to rebuild voice profile' });
  }
});

export default router;

// ===== src/server.ts =====
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import { createServer } from 'http';
import { Server } from 'socket.io';
import dotenv from 'dotenv';

import { connectRedis } from './config/redis';
import { apiLimiter } from './middleware/rateLimiter';
import authRoutes from './routes/auth.routes';
import agentRoutes from './routes/agent.routes';
import chatController from './controllers/chat.controller';

dotenv.config();

const app = express();
const httpServer = createServer(app);
const io = new Server(httpServer, {
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    methods: ['GET', 'POST'],
  },
});

// Middleware
app.use(helmet());
app.use(cors({ origin: process.env.FRONTEND_URL }));
app.use(express.json());
app.use(apiLimiter);

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/agents', agentRoutes);

app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// WebSocket
io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);

  socket.on('send-message', (data) => {
    chatController.handleMessage(socket, data);
  });

  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });
});

// Start server
const PORT = process.env.PORT || 5000;

const startServer = async () => {
  try {
    await connectRedis();
    
    httpServer.listen(PORT, () => {
      console.log(`✓ Server running on port ${PORT}`);
      console.log(`✓ Environment: ${process.env.NODE_ENV}`);
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();
